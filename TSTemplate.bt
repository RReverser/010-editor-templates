//--------------------------------------
//--- 010 Editor v4.0.3 Binary Template
//
// File:
// Author:
// Revision:
// Purpose:
//--------------------------------------

BitfieldLeftToRight();
BitfieldDisablePadding();

typedef struct {
    uint64 base : 33 <name = "Base", comment = "System time clock divided by 90000">;
    uint reserved : 6 <hidden = true>;
    uint extension : 9 <name = "Extension", comment = "Lowest nine bits from the system time clock at the moment of arrival of the last byte of the packet">;
} PCR <name = "Program Clock Reference", size = 6, read = ReadPCR, write = WritePCR, comment = "periodically transmitted value of 42 bits which is used to properly demultiplex packets and to assure that audio matches video">;

uint ReadPCR(PCR pcr) {
    string s;
    SPrintf(s, "%Lu", 300 * pcr.base + pcr.extension);
    return s;
}

void WritePCR(PCR &pcr, string s) {
    uint64 t;
    SScanf(s, "%Lu", t);
    pcr.base = t / 300;
    pcr.extension = t % 300;
}

typedef struct {
    ubyte length <hidden = true>;
    ubyte data[length] <name = "Data", format = hex>;
} Field <size = GetFieldSize>;

int GetFieldSize(Field &field) {
    return ReadUByte(startof(field)) + 1;
}

typedef struct {
    ubyte length <hidden = true>;
    ubyte discontinuity : 1 <name = "Discontinuity indicator", comment = "Current TS packet is in a discontinuity state with respect to either the continuity counter or the program clock reference">;
    ubyte randomAccess : 1 <name = "Random access indicator", comment = "PES packet in this TS packet starts a video/audio sequence">;
    ubyte priority : 1 <name = "Elementary stream priority indicator">;
    ubyte hasPCR : 1 <name = "PCR flag", comment = "Contains PCR field", hidden = true>;
    ubyte hasOPCR : 1 <name = "OPCR flag", comment = "Contains OPCR field", hidden = true>;
    ubyte hasSplicingPoint : 1 <name = "Splicing point flag", comment = "Contains splice countdown field in adaptation field", hidden = true>;
    ubyte hasTransportPrivateData : 1 <name = "Transport private data flag", comment = "Contains private data bytes in adaptation field">;
    ubyte hasExtension : 1 <name = "Extension flag", comment = "Contains adaptation field extension">;

    if (hasPCR) {
        PCR pcr;
    }

    if (hasOPCR) {
        PCR opcr <name = "Original Program Clock Reference">;
    }

    if (hasSplicingPoint) {
        byte spliceCountdown <name = "Splice countdown", comment = "Indicates how many TS packets from this one a slicing point occurs">;
    }

    if (hasTransportPrivateData) {
        Field privateData <name = "Private data">;
    }

    if (hasExtension) {
        Field extension <name = "Extension">;
    }
} AdaptationField <name = "Adaptation Field", size = GetAdaptationFieldSize>;

int GetAdaptationFieldSize(AdaptationField &field) {
    return ReadUByte(startof(field)) + 1;
}

typedef struct {
    struct {
        ubyte syncByte <hidden = true>;
        if (syncByte != 0x47) {
            Warning("Sync byte is not correct (got 0x%02x instead of 0x47).", syncByte);
            return;
        }
    
        ubyte transportError : 1 <name = "Transport error", comment = "Set if bit error exists in packet">;
        ubyte payloadStart : 1 <name = "Payload start", comment = "Start of PES data or PSI otherwise zero only">;
        ubyte transportPriority : 1 <name = "Transport priority", comment = "Higher priority than other packets with the same PID">;
        uint pid : 13 <name = "Packet ID", comment = "Packet Identifier describes stream number or type of data">;
    
        ubyte scramblingControl : 2 <name = "Scrambling control", format = binary, comment = "00: not scrambled; others user-defined">;
        ubyte hasAdaptationField : 1 <name = "Adaptation Field Exists", hidden = true>;
        ubyte hasPayload : 1 <name = "Payload Exists", hidden = true>;
        ubyte contCounter : 4 <name = "Continuity Counter", comment = "Increments for payloads only">;
    } header <name = "Header">;
        
    if (header.hasAdaptationField) {
        AdaptationField adaptationField;
    }

    if (header.hasPayload) {
        ubyte data[188 - (FTell() - startof(this))] <name = "Payload Data", format = hex>;
    }
} TSPacket <name = "Transport Stream Packet", size = 188, optimize = true>;

local int pos = FTell();
while (ReadUByte(pos) != 0x47) pos++;
FSeek(pos);
TSPacket tsPackets[(FileSize() - pos) / 0xBC];

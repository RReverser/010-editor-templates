//--------------------------------------
//--- 010 Editor v4.0.3 Binary Template
//
// File:
// Author:
// Revision:
// Purpose:
//--------------------------------------

BigEndian();
BitfieldLeftToRight();
BitfieldDisablePadding();

typedef enum <ubyte> {
    no,
    yes
} bool;

typedef struct {
    uint64 base : 33 <name = "Base", comment = "System time clock divided by 90000">;
    uint reserved : 6 <hidden = true>;
    uint extension : 9 <name = "Extension", comment = "Lowest nine bits from the system time clock at the moment of arrival of the last byte of the packet">;
} PCR <name = "Program Clock Reference", size = 6, read = ReadPCR, write = WritePCR, comment = "periodically transmitted value of 42 bits which is used to properly demultiplex packets and to assure that audio matches video">;

uint ReadPCR(PCR pcr) {
    string s;
    SPrintf(s, "%Lu", 300 * pcr.base + pcr.extension);
    return s;
}

void WritePCR(PCR &pcr, string s) {
    uint64 t;
    SScanf(s, "%Lu", t);
    pcr.base = t / 300;
    pcr.extension = t % 300;
}

typedef struct {
    ubyte length <hidden = true>;
    ubyte data[length] <name = "Data", format = hex>;
} Field <size = GetFieldSize>;

int GetFieldSize(Field &field) {
    return ReadUByte(startof(field)) + 1;
}

typedef struct {
    ubyte length <hidden = true>;
    bool discontinuity : 1 <name = "Discontinuity indicator", comment = "Current TS packet is in a discontinuity state with respect to either the continuity counter or the program clock reference">;
    bool randomAccess : 1 <name = "Random access indicator", comment = "PES packet in this TS packet starts a video/audio sequence">;
    bool priority : 1 <name = "Elementary stream priority indicator">;
    bool hasPCR : 1 <name = "PCR flag", comment = "Contains PCR field", hidden = true>;
    bool hasOPCR : 1 <name = "OPCR flag", comment = "Contains OPCR field", hidden = true>;
    bool hasSplicingPoint : 1 <name = "Splicing point flag", comment = "Contains splice countdown field in adaptation field", hidden = true>;
    bool hasTransportPrivateData : 1 <name = "Transport private data flag", comment = "Contains private data bytes in adaptation field", hidden = true>;
    bool hasExtension : 1 <name = "Extension flag", comment = "Contains adaptation field extension", hidden = true>;

    if (hasPCR) {
        PCR pcr;
    }

    if (hasOPCR) {
        PCR opcr <name = "Original Program Clock Reference">;
    }

    if (hasSplicingPoint) {
        byte spliceCountdown <name = "Splice countdown", comment = "Indicates how many TS packets from this one a slicing point occurs">;
    }

    if (hasTransportPrivateData) {
        Field privateData <name = "Private data">;
    }

    if (hasExtension) {
        Field extension <name = "Extension">;
    }
} AdaptationField <name = "Adaptation Field", size = GetAdaptationFieldSize>;

int GetAdaptationFieldSize(AdaptationField &field) {
    return ReadUByte(startof(field)) + 1;
}

typedef struct {
    ubyte prefix[3] <hidden = true>;
    ubyte streamId <name = "Stream ID", format = hex, comment = "0xC0 - 0xDF = audio stream, 0xE0 - 0xEF = video stream, 0xFA = MPEG-4 Part 1 SL (Synchronization Layer) stream">;
    uint16 length <hidden = false>;
    // TODO: add other fields
} PES <name = "Packetized Elementary Stream", comment = "Compliant with MPEG-2 Part 1 (Systems) (ISO/IEC 13818-1) and ITU-T H.222.0">;

typedef struct {
    struct {
        ubyte syncByte <hidden = true>;
        if (syncByte != 0x47) {
            Warning("Sync byte is not correct (got 0x%02x instead of 0x47).", syncByte);
            return;
        }
    
        bool transportError : 1 <name = "Transport error", comment = "Set if bit error exists in packet">;
        bool payloadStart : 1 <name = "Payload start", comment = "Start of PES data or PSI otherwise zero only">;
        bool transportPriority : 1 <name = "Transport priority", comment = "Higher priority than other packets with the same PID">;
        uint pid : 13 <name = "Packet ID", comment = "Packet Identifier describes stream number or type of data; 0 = Program Association Table, 1 = Conditional Access Table, 0x1FFF = NULL packet">;
    
        enum <ubyte> {not_scrambled} scramblingControl : 2 <name = "Scrambling control">;
        bool hasAdaptationField : 1 <name = "Adaptation Field Exists", hidden = true>;
        bool hasPayload : 1 <name = "Payload Exists", hidden = true>;
        ubyte contCounter : 4 <name = "Continuity Counter", comment = "Increments for payloads only">;
    } header <name = "Header", size = 4>;
        
    if (header.hasAdaptationField) {
        AdaptationField adaptationField;
    }

    if (header.hasPayload) {
        local ubyte pesPrefix[3];
        ReadBytes(pesPrefix, FTell(), 3);
        if (pesPrefix[0] == 0x00 && pesPrefix[1] == 0x00 && pesPrefix[2] == 0x01) {
            PES pes;
        } else {
            ubyte data[188 - (FTell() - startof(this))] <name = "Payload Data", format = hex, comment = "Not compliant with MPEG-2 Part 1 (Systems) (ISO/IEC 13818-1) and ITU-T H.222.0">;
        }
    }
} TSPacket <name = "Transport Stream Packet", size = 188, optimize = true>;

local int pos = FTell();
while (ReadUByte(pos) != 0x47) pos++;
FSeek(pos);
TSPacket tsPackets[(FileSize() - pos) / 0xBC];
